# 文件列表系统

> 项目要求： 允许在百万级数据基础上协同操作的文件列表

## 项目技术栈

前端： solidjs、tailwind、socket.io<br/>
后端： koa、redis、mysql、socket.io

solidjs是代替react的首选框架，他结合了react hook和jsx的优秀编写方式，以及融合了vue模板，抛弃了沉重的vdom设计，减小运行时压力，速度仅次于原生js。<br/>
tailwind是前端样式解决方案，采用编写样式类名的方式对元素处理。<br/>
socket.io是websocket的封装库，很好的处理了websocket的心跳等一些必要性的特性，比起ws它给予了前后端可以使用的解决方案。ws作为其引擎的方式存在



## 解决方案

### 思路
对于百万级本身并不复杂，对每个文件夹单独加载其内容，那么目录层级再深也不会出现服务端的处理压力。在列表操作中，基础操作有三个（增、删、改），移动可以拆分为删和增，复制也一样。<br/>
对于三个操作元，删除操作会在协同情况下有可能和另外两种操作产生冲突，如：A删除了a文件，B修改了a文件。基于编辑算法OT，有相对复杂的操作，记录字符个数等。但对于文件列表我们没有这么严苛的使用限制，如果A删除了a文件，B修改就直接失败，只需要将失败的结果有效的反馈给B用户即可。<br/>
一个好的编辑工具应该记录了操作历史，可以回滚到历史的某个操作下，所以对于每个操作都应该记录并生成操作栈。如果有较大的回退操作，比如回到100次操作前的文件列表，使用数据库的回滚操作非常的麻烦，性能也并不友好。所以对于操作栈的处理使用缓存处理，将操作栈溢出的操作执行数据库操作，将操作栈的整个内容放在客户端交给客户端去处理，当然文件列表对应的实际物理文件我们需要提供其他方式于其结合，如创建一个带有时间期限的桶，桶内提供的文件都是临时的，这样关于实际文件与文件列表的操作也算是解耦了。<br/>

### 详细
操作栈的添加与获取应该上锁避免达到设定操作栈上限（100次操作）的同一时间又一次性添加了好多条数据，操作栈存储在redis中。前端可以在获取单个文件列表的时候对操作栈的操作进行对应的处理，一定的可能性能分解同时处理100次操作的压力，面对极端情况，如果是10000次操作，都是面对同一个目录层级的，需要提供一个worker来分解压力。

![详情](/docs/detail.png)


## 界面


![界面](/docs/show.png)
![操作](/docs/show.gif)

<!-- mp4格式 -->
<!-- <video id="video" controls="" preload="none" poster="封面">
      <source id="mp4" src="/docs/show.mp4" type="video/mp4">
</videos> -->


## 进度

### 已完成

项目前端框架，solid、tailwind<br/>
项目后端框架，redis、mysql、koa<br/>
websocket通讯、操作栈、同步操作处理<br/>

### 未完成

框架结构优化<br/>
worker处理队列<br/>
redis存储、操作栈溢出数据库处理<br/>
代码优化<br/>
更多... <br/>
